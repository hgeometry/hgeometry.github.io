<!DOCTYPE html><head><meta name="viewport" content="width=device-width, initial-scale=1"><title>HGeometry</title><link href="/style.2b899baf.css" rel="stylesheet"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin><script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin onload="renderMathInElement(document.body);"></script></head><a class="github-corner" href="https://github.com/noinia/hgeometry" aria-label="View source on GitHub"><svg width="80" height="80" style="position:fixed;top:0;border:0;right:0" aria-hidden="true" fill="#64ceaa" color="#fff"><path d="M0 0l115 115h15l12 27 108 108V0z"/><path class="octo-arm" d="M128.3 109c-14.5-9.3-9.3-19.4-9.3-19.4 3-6.9 1.5-11 1.5-11-1.3-6.6 2.9-2.3 2.9-2.3 3.9 4.6 2.1 11 2.1 11-2.6 10.3 5.1 14.6 8.9 15.9" fill="currentColor" style="transform-origin:130px 106px"/><path class="octo-body" d="M115 115c-.1.1 3.7 1.5 4.8.4l13.9-13.8c3.2-2.4 6.2-3.2 8.5-3-8.4-10.6-14.7-24.2 1.6-40.6 4.7-4.6 10.2-6.8 15.9-7 .6-1.6 3.5-7.4 11.7-10.9 0 0 4.7 2.4 7.4 16.1 4.3 2.4 8.4 5.6 12.1 9.2 3.6 3.6 6.8 7.8 9.2 12.2 13.7 2.6 16.2 7.3 16.2 7.3-3.6 8.2-9.4 11.1-10.9 11.7-.3 5.8-2.4 11.2-7.1 15.9-16.4 16.4-30 10-40.6 1.6.2 2.8-1 6.8-5 10.8L141 136.5c-1.2 1.2.6 5.4.8 5.3z" fill="currentColor"/></svg></a><main><header><h1><a href="/">HGeometry</a></h1><h2>Computational Geometry in Haskell</h2><div class="btn"><a href="https://github.com/noinia/hgeometry">GitHub</a><a href="https://discord.gg/HQwbD9jWqg">Discord</a><a href="https://hackage.haskell.org/package/hgeometry">API Reference</a><a href="/overview.html">Landscape</a><a href="/correctness.html">Correctness</a></div></header><article><p><b>HGeometry</b> is a library for computing with geometric objects in Haskell. It defines basic geometric types and primitives, and implements many algorithms, including:</p><div id="algo-list"><div>\( O(n \log n) \)</div><div><a href="#convex-hull">Convex Hull.</a></div><div>\( O(k) \)</div><div><a href="#fast-visibility">Visibility polygon.</a></div><div>\( O(n) \)</div><div><a href="https://en.wikipedia.org/wiki/Smallest-circle_problem">Smallest enclosing disk.</a></div><div> \( O(n \log n) \) </div><div><a href="https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm">Douglas Peucker&apos;s simplification algorithm.</a></div><div>\( O(\log n) \) </div><div><a href="https://en.wikipedia.org/wiki/Extreme_point">Convex extremes and tangents.</a></div><div>\( O(n \log n) \)</div><div><a href="https://en.wikipedia.org/wiki/Delaunay_triangulation">Delaunay triangulation.</a></div><div>\( O(n \log n) \)</div><div><a href="https://en.wikipedia.org/wiki/Euclidean_minimum_spanning_tree">Euclidean Minimum Spanning Tree.</a></div><div>\( O(1/\varepsilon^dn\log n) \)</div><div><a href="https://en.wikipedia.org/wiki/Well-separated_pair_decomposition">Well-Separated pair decomposition.</a></div><div>\( O(n+m) \)</div><div><a href="https://en.wikipedia.org/wiki/Minkowski_addition">Minkowski sum.</a></div><div>\( O(n\log n) \)</div><div><a href="#closest-pair">Closest pair of points.</a></div><div>\( O(nm) \)</div><div><a href="https://en.wikipedia.org/wiki/Fr%C3%A9chet_distance">Fr&eacute;chet distance.</a></div><div>\( O(n) \)</div><div><a href="#shortest-path">Single-source shortest path tree.</a></div></div><p>Geometry is inherently visual and the rest of this website is devoted to illustrations and animations that highlight how the various algorithms work.</p></article><article class="feature" id="inflate"><h2>\( O(n) \) Inflate</h2><div><p>Polygons can be inflated like a balloon. A partially inflated polygon is smaller than the original polygon and have the property that each point on the wavefront are equidistant to the point of origin. Increasing the distance to the wavefront gives the impression of the polygon spreading like water in a mold.</p></div><div><video mute="" loop controls><source src="/inflate.5d929473.mp4" type="video/mp4"><source src="https://f002.backblazeb2.com/file/hgeometry/inflate.mp4" type="video/mp4"><source src="https://github.com/hgeometry/hgeometry.github.io/raw/main/assets/inflate.mp4" type="video/mp4"></video></div></article><article class="feature" id="fast-visibility"><h2>\( O(k) \) Visibility</h2><div><p>Finding the visible parts of a polygon from a given point is a cornerstone in computational geometry. There exists many algorithms but one is of special interest. This algorithm is output-sensitive, meaning that the runtime is dependent not on the size of the input polygon but on the size of the visible area.</p><p>The animation shows how a polygon is first triangulated, then the triangles are processed and marked in grey while the visibility polygon is outlined in green. The number of processed triangles is limited to those that intersect the final visibility polygon.</p></div><div><video mute="" loop controls><source src="/fast_visibility.d4286177.mp4" type="video/mp4"><source src="https://f002.backblazeb2.com/file/hgeometry/fast_visibility.mp4" type="video/mp4"><source src="https://github.com/hgeometry/hgeometry.github.io/raw/main/assets/fast_visibility.mp4" type="video/mp4"></video></div></article><article class="feature" id="convex-hull"><h2>\( O(n \log n) \) Convex Hull</h2><div><p>A convex hull of a set of points is the smallest convex polygon that contains it. You can think of it as a rubber band that stretches around a collection of points.</p><p>So, how is this useful? Well, there are many fast algorithms that only work on convex polygons. For example, there&apos;s a fast algorithm for finding the two corners that are furthest away from each other. By first finding the convex hull, we can then use the fast algorithm to find the two extreme points in the set.</p><p><a href="https://en.wikipedia.org/wiki/Convex_hull">Wikipedia article.</a></p></div><div><video mute="" loop controls><source src="/convexhull.1d7db4f6.mp4" type="video/mp4"><source src="https://f002.backblazeb2.com/file/hgeometry/convexhull.mp4" type="video/mp4"><source src="https://github.com/hgeometry/hgeometry.github.io/raw/main/assets/convexhull.mp4" type="video/mp4"></video></div></article><article class="feature" id="closest-pair"><h2>\( O(n \log n) \) Closest Pair</h2><div><p>The closest pair problem for points in the Euclidean plane was among the first geometric problems that were treated at the origins of the systematic study of the computational complexity of geometric algorithms.</p><p><a href="https://en.wikipedia.org/wiki/Closest_pair_of_points_problem">Wikipedia article.</a></p></div><div><video mute="" loop controls><source src="/closestpair.2d24f70f.mp4" type="video/mp4"><source src="https://f002.backblazeb2.com/file/hgeometry/closestpair.mp4" type="video/mp4"><source src="https://github.com/hgeometry/hgeometry.github.io/raw/main/assets/closestpair.mp4" type="video/mp4"></video></div></article><article class="feature" id="random-monotone"><h2>\( O(n \log n) \) Random, Monotone Polygons</h2><div><p>Monotone polygons have the property that all rays in a certain direction only intersect the polygon in at most two places. These kinds of polygons play a key role in many algorithms such as triangulation and being able to quickly generate random samples helps immensely with testing.</p><p><a href="https://en.wikipedia.org/wiki/Monotone_polygon">Wikipedia article.</a></p></div><div><video mute="" loop controls><source src="/random_monotone.25773662.mp4" type="video/mp4"><source src="https://f002.backblazeb2.com/file/hgeometry/random_monotone.mp4" type="video/mp4"><source src="https://github.com/hgeometry/hgeometry.github.io/raw/main/assets/random_monotone.mp4" type="video/mp4"></video></div></article><article class="feature" id="bentleyottmann"><h2>\( O((n+k) \log n) \) Line segment intersection</h2><div><p>Using a brute-force search, finding intersections of \(n\) lines would take \(O(n^2)\) time. Since we often want to find intersections, the Bentley-Ottmann algorithm which significantly improved the efficiency.</p><p>When is this used? Well, to give good error messages, HGeometry will check polygons for self-intersections immediately when they&apos;re created. This leads to mistakes being spotted sooner rather than later.</p><p><a href="https://en.wikipedia.org/wiki/Bentley%E2%80%93Ottmann_algorithm">Wikipedia article</a></p></div><div><video mute="" loop controls><source src="/bentleyottmann.41b1043e.mp4" type="video/mp4"><source src="https://f002.backblazeb2.com/file/hgeometry/bentleyottmann.mp4" type="video/mp4"><source src="https://github.com/hgeometry/hgeometry.github.io/raw/main/assets/bentleyottmann.mp4" type="video/mp4"></video></div></article><article class="feature" id="zhashing"><h2>Fast Z-Hashing Triangulation</h2><div><p>Finding points inside an arbitrary bounding box is made significantly faster with Z-hashing. By first sorting a polygon's vertices by their z-hash, the polygon can be triangulated in near linear time. While other algorithms offer stronger guarantees about worst-case behavior, z-order hashing has the lowest constant-factor overhead and is, in practice, the fastest known triangulation algorithm.</p><p><a href="https://en.wikipedia.org/wiki/Z-order_curve">Wikipedia article</a></p></div><div><video mute="" loop controls><source src="/zhashing.7bee0f0c.mp4" type="video/mp4"><source src="https://f002.backblazeb2.com/file/hgeometry/zhashing.mp4" type="video/mp4"><source src="https://github.com/hgeometry/hgeometry.github.io/raw/main/assets/zhashing.mp4" type="video/mp4"></video></div></article><article class="feature" id="shortest-path"><h2>\( O(n) \) Single-Source Shortest Path</h2><div><p>Finding the shortest path from a specific corner to all other corners is a key step in many other algorithms. It&apos;s used for computing visibility polygons, inflated polygons, and minimum-link distances.</p><p>The animation shows the shortest internal path from a green point on the side of a polygon to all other corner points.</p>DOI: 10.1007/BF01840360<br></div><div><video mute="" loop controls><source src="/multi.6361dbf5.mp4" type="video/mp4"><source src="https://f002.backblazeb2.com/file/hgeometry/multi.mp4" type="video/mp4"><source src="https://github.com/hgeometry/hgeometry.github.io/raw/main/assets/multi.mp4" type="video/mp4"></video></div></article></main><footer>This site uses material from Wikipedia, which is released under the <a href="https://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-Share-Alike License 3.0</a>. HGeometry is licensed under BSD3. Copyright by Frank Staals, David Himmelstrup, and several contributors. See GitHub for details.</footer><script src="/instantclick.min.b5417da8.js" data-no-instant=""></script><script data-no-instant="">InstantClick.init();</script>