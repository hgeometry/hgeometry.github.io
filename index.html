<!DOCTYPE html>
<html>

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>HGeometry</title>
  <link href="./style.less" rel="stylesheet" />

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
    integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"
    integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4"
    crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
    integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
</head>

<body>
  <a href="https://github.com/noinia/hgeometry" class="github-corner" aria-label="View source on GitHub"><svg width="80"
      height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: fixed; top: 0; border: 0; right: 0;"
      aria-hidden="true">
      <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
      <path
        d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
        fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
      <path
        d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
        fill="currentColor" class="octo-body"></path>
    </svg>
  </a>

  <main>
    <header>
      <h1>HGeometry</h1>
      <h2>Computational Geometry in Haskell</h2>

      <div class="btn">
        <a href="https://github.com/noinia/hgeometry">GitHub</a>
        <a href="https://discord.gg/HQwbD9jWqg">Discord</a>
        <a href="https://hackage.haskell.org/package/hgeometry">API Reference</a>
      </div>
    </header>
    <article>
      <b>HGeometry</b> is a library for computing with geometric objects in Haskell. It defines basic geometric types
      and primitives, and implements many algorithms, including:

      <div id="algo-list">
        <div>\( O(n \log n) \)</div>
        <div><a href="#convex-hull">Convex Hull.</a></div>

        <div>\( O(k) \)</div>
        <div><a href="#fast-visibility">Visibility polygon.</a></div>

        <div>
          \( O(n) \)
        </div>
        <div>
          <a href="https://en.wikipedia.org/wiki/Smallest-circle_problem">Smallest enclosing disk.</a>
        </div>

        <div> \( O(n \log n) \) </div>
        <div>
          <a href="https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm">Douglas Peucker's
            algorithm.</a>
        </div>

        <div> \( O(\log n) \) </div>
        <div>
          <a href="https://en.wikipedia.org/wiki/Extreme_point">Convex extremes and tangents.</a>
        </div>

        <div>\( O(n \log n) \)</div>
        <div>
          <a href="https://en.wikipedia.org/wiki/Delaunay_triangulation">Delaunay triangulation.</a>
        </div>

        <div>\( O(n \log n) \)</div>
        <div>
          <a href="https://en.wikipedia.org/wiki/Euclidean_minimum_spanning_tree">
            Euclidean Minimum Spanning Tree.
          </a>
        </div>

        <div>\( O(1/\varepsilon^dn\log n) \)</div>
        <div><a href="https://en.wikipedia.org/wiki/Well-separated_pair_decomposition">Well-Separated pair
            decomposition.</a></div>

        <div>\( O(n+m) \)</div>
        <div><a href="https://en.wikipedia.org/wiki/Minkowski_addition">Minkowski sum.</a></div>

        <div>\( O(n\log n) \)</div>
        <div><a href="#closest-pair">Closest pair of points.</a></div>

        <div>\( O(nm) \)</div>
        <div><a href="https://en.wikipedia.org/wiki/Fr%C3%A9chet_distance">Fr√©chet distance.</a></div>

        <div>\( O(n) \)</div>
        <div>
          <a href="#shortest-path">Single-source shortest path tree.</a>
        </div>
      </div>

      Geometry is inherently visual and the rest of this website is
      devoted to illustrations and animations that highlight how the various algorithms work.
    </article>

    <article class="feature" id="inflate">
      <h2>\( O(n) \) Inflate</h2>
      <div>
        <p>
          Polygons can be inflated like a balloon. A partially inflated polygon is smaller than the original
          polygon and have the property that each point on the wavefront are equidistant to the point of origin.
          Increasing the distance to the wavefront gives the impression of the polygon spreading like
          water in a mold.
        </p>
      </div>
      <div>
        <video mute loop controls>
          <source src="./assets/inflate.mp4" type="video/mp4">
          <source src="https://f002.backblazeb2.com/file/hgeometry/inflate.mp4" type="video/mp4">
          <source src="https://github.com/hgeometry/hgeometry.github.io/raw/main/assets/inflate.mp4" type="video/mp4">
        </video>
      </div>
    </article>

    <article class="feature" id="fast-visibility">
      <h2>\( O(k) \) Visibility</h2>
      <div>
        <p>
          Finding the visible parts of a polygon from a given point is a cornerstone in
          computational geometry. There exists many algorithms but one is of special interest.
          This algorithm is output-sensitive, meaning that the runtime is dependent not on
          the size of the input polygon but on the size of the visible area.
        </p>
        <p>
          The animation shows how a polygon is first triangulated, then triangles are processed
          and marked in grey while the visibility polygon is outlined in green. The number of
          processed triangles is limited to those that intersect the final visibility polygon.
        </p>
      </div>
      <div>
        <video mute loop controls>
          <source src="./assets/fast_visibility.mp4" type="video/mp4">
          <source src="https://f002.backblazeb2.com/file/hgeometry/fast_visibility.mp4" type="video/mp4">
          <source src="https://github.com/hgeometry/hgeometry.github.io/raw/main/assets/fast_visibility.mp4"
            type="video/mp4">
        </video>
      </div>
    </article>

    <article class="feature" id="convex-hull">
      <h2>\( O(n \log n) \) Convex Hull</h2>
      <div>
        <p>
          A convex hull of a set of points is the smallest convex polygon that contains it.
          You can think of it as a rubber band that stretches around a collection of points.
        </p>
        <p>
          So, how is this useful? Well, there are many fast algorithms that only work on convex
          polygons. For example, there's a fast algorithm for finding the two corners that are
          furthest away from each other. By first finding the convex hull, we can then use the
          fast algorithm to find the two extreme points in the set.
        </p>
        <p>
          <a href="https://en.wikipedia.org/wiki/Convex_hull">Wikipedia article.</a>
        </p>
      </div>
      <div>
        <video mute loop controls>
          <source src="./assets/convexhull.mp4" type="video/mp4">
          <source src="https://f002.backblazeb2.com/file/hgeometry/convexhull.mp4" type="video/mp4">
          <source src="https://github.com/hgeometry/hgeometry.github.io/raw/main/assets/convexhull.mp4"
            type="video/mp4">
        </video>
      </div>
    </article>

    <article class="feature" id="closest-pair">
      <h2>\( O(n \log n) \) Closest Pair</h2>
      <div>
        <p>
          The closest pair problem for points in the Euclidean plane was among the first geometric
          problems that were treated at the origins of the systematic study of the computational
          complexity of geometric algorithms.
        </p>
        <p>
          <a href="https://en.wikipedia.org/wiki/Closest_pair_of_points_problem">Wikipedia article.</a>
        </p>
      </div>
      <div>
        <video mute loop controls>
          <source src="./assets/closestpair.mp4" type="video/mp4">
          <source src="https://f002.backblazeb2.com/file/hgeometry/closestpair.mp4" type="video/mp4">
          <source src="https://github.com/hgeometry/hgeometry.github.io/raw/main/assets/closestpair.mp4"
            type="video/mp4">
        </video>
      </div>
    </article>

    <article class="feature" id="bentleyottmann">
      <h2>\( O((n+k) \log n) \) Line segment intersection</h2>
      <div>
        <p>
          Using a brute-force search, finding intersections of \(n\) lines would take \(O(n^2)\) time.
          Since we often want to find intersections, the Bentley-Ottmann algorithm which significantly
          improved the efficiency.
        </p>
        <p>
          When is this used? Well, to give good error messages, HGeometry will check polygons
          for self-intersections immediately when they're created. This leads to mistakes
          being spotted sooner rather than later.
        </p>
        <p>
          <a href="https://en.wikipedia.org/wiki/Bentley%E2%80%93Ottmann_algorithm">Wikipedia article</a>
        </p>
      </div>
      <div>
        <video mute loop controls>
          <source src="./assets/bentleyottmann.mp4" type="video/mp4">
          <source src="https://f002.backblazeb2.com/file/hgeometry/bentleyottmann.mp4" type="video/mp4">
          <source src="https://github.com/hgeometry/hgeometry.github.io/raw/main/assets/bentleyottmann.mp4"
            type="video/mp4">
        </video>
      </div>
    </article>

    <article class="feature" id="shortest-path">
      <h2>\( O(n) \) Single-Source Shortest Path</h2>

      <div>
        <p>
          Finding the shortest path from a specific corner to all other corners
          is a key step in many other algorithms. It's used for computing visibility
          polygons, inflated polygons, and minimum-link distances.
        </p>
        <p>
          The animation shows the shortest internal path from a green point on the side of a polygon
          to all other corner points.
        </p>
        DOI: 10.1007/BF01840360<br />
      </div>
      <div>
        <video mute loop controls>
          <source src="./assets/multi.mp4" type="video/mp4">
          <source src="https://f002.backblazeb2.com/file/hgeometry/multi.mp4" type="video/mp4">
          <source src="https://github.com/hgeometry/hgeometry.github.io/raw/main/assets/multi.mp4" type="video/mp4">
        </video>
      </div>
    </article>

  </main>

  <footer>
    This page uses material from Wikipedia, which is released under the
    <a href="https://creativecommons.org/licenses/by-sa/3.0/">
      Creative Commons Attribution-Share-Alike License 3.0
    </a>. HGeometry is licensed under BSD3. Copyright by Frank Staals,
    David Himmelstrup, and several contributors. See GitHub for details.
  </footer>

  <script src="./instantclick.min.js" data-no-instant></script>
  <script data-no-instant>InstantClick.init();</script>
</body>

</html>